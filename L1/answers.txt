
1. Какой самый эффективный способ конкатенации строк?

String.Builder рекомендуемый способ конкатенации строк 

2. Что такое интерфейсы, как они применяются в Go?

интерфейсs в go это набор сигнатур методов, которые определяют какой-либо тип

3. Чем отличаются RWMutex от Mutex?

RWMutex позволяет осуществить параллельное чтение. Все readerы будут ждать только writeroв
но не будут ждать других readeroв

4. Чем отличаются буферизированные и не буферизированные каналы?

В отличие от небуферезированных каналов, буферизованные каналы принимают ограниченное 
количество значений без соответствующего приемника для этих значений.

5. Какой размер у структуры struct{}{}?
0

6. Есть ли в Go перегрузка методов или операторов?
В go отсутствует перегрузка методов потому, что "things are simpler without it"

7. В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1
m[1]=124
m[2]=281

Go Specs: The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next.

8. В чем разница make и new?

new выделяет память для заданного типа с "нулевыми" значениями и возвращает ссылку
make используется для создания слайсов, массивов и map. И возвращает не ссылку а само значение

9. Сколько существует способов задать переменную типа slice или map?

3: 
    1. v := make(map[T]T) 
    2. v := map[T]T{} 
    3. var v map[T]T

10. Что выведет данная программа и почему?

func update(p *int) {
        b := 2
        p = &b
}


func main() {
    var (
            a = 1
            p = &a
        )
        fmt.Println(*p)
        update(p)
        fmt.Println(*p)
}


Вывод:
    1
    1

В функцию update передается указатель p. Аргументом функции является новая
локальная переменная. То есть новый указатель, который указывает на ту же 
ячейку памяти. При изменении указателя p в функции updater, указатель p в main
не изменяется. Для того, чтобы в выводе появилась цифра 2. Необходимо изменить
ячейку пямяти. То есть если в функции update написать *p = b, вывод будет таким:
1
2


11. Что выведет данная программа и почему?

func main() {
wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
            go func(wg sync.WaitGroup, i int) {
                fmt.Println(i)
                    wg.Done()
            }(wg, i)
    }
    wg.Wait()
        fmt.Println("exit")
}

Допущена ошибка. В горутину wg передается по значению, поэтому wg.Done()
не срабатывает. Появляется deadlock

Если исправить ошибку:
    go func (wg *sync.WaitGroup, i int) {
        ....
    }(&wg, i)

То вывод чисел 0-4 будет неупорядоченным

12. Что выведет данная программа и почему?

func main() {
       n := 0
       if true {
           n := 1
           n++
       }
       fmt.Println(n)
}

0 т.к. переменная n является локальной для цикла for. (создается новая переменная
n := 1) если изменить := на =, выведется 2

13. Что выведет данная программа и почему?

func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}


func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
        fmt.Println(a)
}

[100, 2, 3, 4, 5]
функция append возвращает новый срез. Локальная переменная v перезапишется 
и будет иметь ссылку на новый базовый массив.

14. Что выведет данная программа и почему?

func main() {
       slice := []string{"a", "a"}
       func(slice []string) {
           slice = append(slice, "a")
               slice[0] = "b"
               slice[1] = "b"
               fmt.Print(slice)
       }(slice)
       fmt.Print(slice)
}

Вывод:
[b , b, b] [a, a]
